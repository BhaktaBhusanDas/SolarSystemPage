<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Stunning 3D Animated Webpage</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background: #000; /* Changed to solid black for space */
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
            z-index: 1;
        }
        .overlay {
            position: absolute;
            top: 40px;
            left: 40px;
            color: #fff;
            z-index: 2;
            font-family: 'Segoe UI', Arial, sans-serif;
            background: rgba(0,0,0,0.4);
            padding: 24px 36px;
            border-radius: 18px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            backdrop-filter: blur(6px);
            animation: fadeIn 2s;
        }
        .btn-3d {
            margin-top: 24px;
            padding: 12px 32px;
            font-size: 1.2em;
            border: none;
            border-radius: 8px;
            background: linear-gradient(90deg, #43cea2, #185a9d);
            color: #fff;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(67,206,162,0.3);
            transition: transform 0.3s cubic-bezier(.25,.8,.25,1), box-shadow 0.3s;
            perspective: 600px;
        }
        .btn-3d:hover {
            transform: rotateY(20deg) scale(1.08);
            box-shadow: 0 8px 32px rgba(24,90,157,0.4);
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-40px);}
            to { opacity: 1; transform: translateY(0);}
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div class="overlay">
        <h1>Stunning 3D Animations - Version 7</h1>
        <p>Experience interactive 3D transitions and animations powered by Three.js.</p>
        <button class="btn-3d" id="transitionBtn">3D Transition</button>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
    <script>
        // --- SOLAR SYSTEM BACKGROUND ---
        let scene = new THREE.Scene();
        let camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
        let renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        // Add stars background
        function createStars(count) {
            let geometry = new THREE.BufferGeometry();
            let positions = [];
            for (let i = 0; i < count; i++) {
                let x = (Math.random() - 0.5) * 2000;
                let y = (Math.random() - 0.5) * 2000;
                let z = (Math.random() - 0.5) * 2000;
                positions.push(x, y, z);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            let material = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2 });
            let stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }
        createStars(2000);

        // Sun
        let sunGeometry = new THREE.SphereGeometry(3, 32, 32);
        let sunMaterial = new THREE.MeshBasicMaterial({ color: 0xfff200 });
        let sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);

        // Sun glow
        let sunGlowMaterial = new THREE.MeshBasicMaterial({ color: 0xfff200, transparent: true, opacity: 0.18 });
        let sunGlow = new THREE.Mesh(new THREE.SphereGeometry(5.5, 32, 32), sunGlowMaterial);
        scene.add(sunGlow);

        // Planets data: [radius, distance from sun, color, orbital speed]
        let planetsData = [
            [0.5, 6, 0xc2b280, 0.015], // Mercury
            [0.7, 8, 0xe6c89f, 0.012], // Venus
            [0.8, 10, 0x3a9efd, 0.01], // Earth
            [0.6, 12, 0xff6f61, 0.008], // Mars
            [1.5, 16, 0xf4e2d8, 0.005], // Jupiter
            [1.2, 20, 0xd1c7b7, 0.004], // Saturn
            [1.0, 24, 0x7ec0ee, 0.003], // Uranus
            [1.0, 28, 0x4169e1, 0.002]  // Neptune
        ];

        let planets = [];
        let orbits = [];
        planetsData.forEach(([radius, dist, color, speed], idx) => {
            // Planet mesh
            let geo = new THREE.SphereGeometry(radius, 24, 24);
            let mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.6, metalness: 0.2 });
            let mesh = new THREE.Mesh(geo, mat);
            mesh.position.x = dist;
            scene.add(mesh);
            planets.push({ mesh, dist, speed, angle: Math.random() * Math.PI * 2 });

            // Orbit ring
            let orbitGeo = new THREE.RingGeometry(dist - 0.01, dist + 0.01, 64);
            let orbitMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.12 });
            let orbit = new THREE.Mesh(orbitGeo, orbitMat);
            orbit.rotation.x = Math.PI / 2;
            scene.add(orbit);
            orbits.push(orbit);
        });

        // Lighting
        let ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        let pointLight = new THREE.PointLight(0xfff200, 2.5, 100);
        pointLight.position.set(0, 0, 0);
        scene.add(pointLight);

        camera.position.set(0, 10, 38);
        camera.lookAt(0, 0, 0);

        // Mouse interaction for rotation
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };
        document.addEventListener('mousemove', (e) => {
            let nx = (e.clientX / window.innerWidth) * 2 - 1;
            let ny = (e.clientY / window.innerHeight) * 2 - 1;
            targetRotation.y = nx * Math.PI * 0.4;
            targetRotation.x = ny * Math.PI * 0.2;
        });

        // Animation loop
        function animateSolarSystem() {
            requestAnimationFrame(animateSolarSystem);

            // Smooth camera rotation
            currentRotation.x += (targetRotation.x - currentRotation.x) * 0.07;
            currentRotation.y += (targetRotation.y - currentRotation.y) * 0.07;
            camera.position.x = Math.sin(currentRotation.y) * 38;
            camera.position.y = 10 + Math.sin(currentRotation.x) * 10;
            camera.position.z = Math.cos(currentRotation.y) * 38;
            camera.lookAt(0, 0, 0);

            // Animate planets
            planets.forEach((planet, i) => {
                planet.angle += planet.speed * 0.7;
                planet.mesh.position.x = Math.cos(planet.angle) * planet.dist;
                planet.mesh.position.z = Math.sin(planet.angle) * planet.dist;
            });

            renderer.render(scene, camera);
        }
        animateSolarSystem();

        // 3D Transition on button click (kept as a fun effect)
        document.getElementById('transitionBtn').addEventListener('click', () => {
            let start = null;
            let duration = 1800;
            let from = {x: camera.position.x, y: camera.position.y, z: camera.position.z};
            let to = {x: 0, y: 30, z: 0};
            function transition(ts) {
                if (!start) start = ts;
                let progress = Math.min((ts - start) / duration, 1);
                let ease = progress < 0.5
                    ? 2 * progress * progress
                    : -1 + (4 - 2 * progress) * progress;
                camera.position.x = from.x * (1-ease) + to.x * ease + Math.sin(progress*4*Math.PI)*2;
                camera.position.y = from.y * (1-ease) + to.y * ease;
                camera.position.z = from.z * (1-ease) + 2 * (1-ease) + 6 * ease;
                camera.lookAt(0,0,0);
                if (progress < 1) {
                    requestAnimationFrame(transition);
                }
            }
            requestAnimationFrame(transition);
        });

        // Responsive
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>